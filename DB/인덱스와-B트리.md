# 인덱스
- 데이터를 빠르게 찾을 수 있는 하나의 장치
- 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조
- 테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
- 컬럼의 값과 물리적 주소를 Key-Value의 한 쌍으로 저장

## 장점
- 테이블을 검색하는 속도와 성능의 향상
- 시스템의 전반적인 부하를 줄일 수 있음
- ORDER BY / MAX / MIN 과 같은 것도 이미 정렬이 되어있으니 빠르게 수행 가능

## 단점
- 인덱스를 관리하기 위한 추가 작업 필요
- 추가 저장공간 필요
- 잘못 사용하면 오히려 검색 성능 저하
- 데이터의 수정이 잦은 경우 성능 저하<br> ->
인덱스를 항상 정렬된 상태로 유지해야하니 인덱스가 적용된 컬럼엔 다음과 같은 작업에선 추가 작업이 필요하다.
    - INSERT : 새로운 데이터에 대한 인덱스를 추가
    - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
    - UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
    ```
    [참고] : 데이터의 인덱스는 삭제하는 것이 아닌, **사용하지 않음** 으로 처리됩니다. 따라서 수정 작업이 많으면 실제 데이터에 비해 인덱스가 과도하게 커집니다. (별도의 메모리 공간에 저장되기 때문에 추가 저장 공간이 많이 필요해집니다.)
    ```

## 인덱스를 사용하면 좋은 경우
인덱스를 효율적으로 사용하려면 data의 range가 넓고 중복이 적은, 조회가 많거나 정렬된 상태가 유용할 때 사용하는 것이 좋다.
- 규모가 큰 테이블
- INSERT, UPDATE, DELETE 작업이 자주 발생하지 않는 컬럼
- 데이터의 중복도가 낮은 컬럼

# B-Tree
인덱스는 보통 B-Tree 자료 구조로 이루어져 있다.<br>
이는 루트 노드, 리프 노드, 이 둘 사이에 있는 브랜치 노드로 나뉜다.
<br>**(이 부분은 책을 꼭 참고하길 바랍니다.)**

![Btree](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBLi5L%2FbtrdInhxyVP%2Febff3uYkmyoEty5lULR8kK%2Fimg.png)

트리의 탐색은 맨 위 루트 노드부터 탐색하며, 브랜치 노드를 거쳐 리프 노드까지 내려간다.<br><br>
예를 들면, 위 그림에서 "10"을 찾으려면, **10보다 같거나 클 때까지**를 기반으로 시작한다.
<br>
7을 거쳐 15가 되기 전에 내려가고(10 < 15), 9를 거쳐 11이 되기 전에 내려간다(10  < 11).
<br>
그럼 10을 발견할 수 있다.<br><br>
위 과정은 정렬된 값을 기반으로 탐색하는 것을 볼 수 있고, 루트 노드부터 시작해 마지막 리프 노드에 도달하여 10이 가리키는 데이터 포인터를 통해 결과값을 반환한다.

## 인덱스가 효율적인 이유와 대수확장성
인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수 확장성 때문이다.<br>
```
대수확장성?
트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가한다.
```
대수확장성 덕분에 트리 깊이는 열 개짜리로 100만 개의 레코드를 검색할 수 있다.<br>
인덱스는 이것보다 훨씬 더 효율적이다.

---

## 추가 내용
B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야하는 비효율적인 면이 있다.<br><br>
이를 개선시킨 자료구조로 **B+Tree**가 있다.

B+Tree는 오직 leaf node에만 데이터를 저장하고, leaf node가 아닌 node에서는 자식 포인터만 저장한다. 그리고 leaf-node끼리는 Linked list로 연결되어 있다.<br>
또한 B+Tree는 반드시 leaf node에만 데이터가 저장되기 때문에 중간 node에서 Key를 올바르게 찾아가기 위해 key가 중복될 수 있다.
![B+Tree](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAARBC%2FbtrdDydoUp7%2F9h4KOXBRyDNKpKDAe2ugq0%2Fimg.png)
<br><br>

### 장점
1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다. 
2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모된다. 반면 B-Tree는 모든 node를 확인해야 한다. 

### 단점
- B-Tree의 경우 최상의 경우 특정 key를 root node에서 찾을 수 있지만, B+Tree의 경우 반드시 특정 key에 접근하기 위해서 leaf node까지 가야 하는 단점이 있다.

### 인덱스에서 B+Tree를 사용하는 이유
- 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생할 수 있다.
    - B+Tree의 linked list를 이용하면 순차 검색을 효율적으로 할 수 있음

---
### 이미지 출처<br>

https://rebro.kr/167
