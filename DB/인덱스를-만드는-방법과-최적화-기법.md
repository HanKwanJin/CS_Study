# 인덱스를 만드는 방법
1. **MySQL**

MySQL에는 `클러스터형 인덱스`와 `세컨더리 인덱스`가 존재한다.

### 클러스터형 인덱스 
- 테이블당 하나를 설정할 수 있음.  
- primary key로 기본키를 만들면 클러스터형 인덱스 생성 가능 
- 기본키를 만들지 않고 unique not null 로 클러스터형 인덱스 생성 가능 

### 세컨더리 인덱스 
- ```create index ...``` 명령어 사용 
- 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 떄 생성해야하는 인덱스 

### 사용하는 경우 
하나의 인덱스만 생성할 것이라면 **클러스터형 인덱스**를 만드는 것이 성능이 좋다. 

**세컨더리 인덱스**는 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하기 때문에 age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때 사용해야한다. 
<br>
<br>

2. **MongoDB**

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨
- 세컨더리키도 부가적으로 설정해 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수도 있다.


아래와 같이 컬렉션(numbers)에 `createIndex()` 명령을 사용하여 num 키에 대한 인덱스를 생성해보았다. 
```
> db.numbers.createIndex({num: 1},{name:"index_num"})

-- 결과 메세지 
{
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 2,
        "ok" : 1
}
```

위의 예제에서는 num 키에 대해서 인덱스를 생성하는 것이며 :1 은 오름차순 정렬을 의미하며 :-1은 내림차순 정렬을 의미한다. 그리고 인덱스 이름은 index_num 으로 생성했다.

이제 결과 메세지를 살펴보자 
- **createdCollectionAutomatically** : createIndex() 명령어를 통해 새로운 collection을 생성했는지 여부이다. 기존 collection에 unique key만 생성한 것이라면 false가 정상이다. 만약 기존에 없는 collection에 위 명령어를 사용하면 새로운 collection을 생성하면서 이 값은 true를 반환한다.
- **numIndexesBefore** : 인덱스를 생성하기 전의 인덱스 수를 의미
- **numIndexesAfter** : 생성 후 인덱스 수를 의미
컬렉션이 생성되면 _id 에 대해서 프라이머리 키가 생성되기 때문에 생성 전이 1이고, 인덱스 생성 후가 2 인 것을 확인 할 수 있다.
<br>
<br>

# 인덱스 최적화 기법 (MongoDB 기준)

### 1. 인덱스는 비용이다. 

인덱스는 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 두번 탐색하게 된다. 

또한 컬렉션이 수정되었을 때 인덱스로 수정되어야 하기 때문에 B-트리의 높이를 균형있게 조절하는 비용도 들고, 데이터를 효율적으로 조히할 수 있도록 분산시키는 비용도 들게된다. 

그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 좋지 않다. 또한 컬렉션에서 가져와야 하는 양이 많다면 이 또한 인덱스르 사용하는 것이 좋지 않다. 
<br><br>

### 2. 항상 테스팅하라. 

인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다. 그렇기 때문에 항상 테스팅하는 것이 중요하다. 
아래와 같이 `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화 해야한다. (MySQL 기준)
```
explain select * from t1 join t2 on t1.c1 = t2.c1
```
<br>

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다. 

복합 인덱스를 생성할 때에는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다. 때문에 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다. 

1) 어떠한 값과 같음을 비교하는 `==` 이나 `equal` 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다. 
2) 정렬에 쓰는 필드라면 그다음 인덱스로 설정한다. 
3) 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 `>` 이거나 `<` 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정하자. 
4) 유니크한 값의 정도를 카디널리티라고 하는데, 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다. 예를 들어 age와 email이 있다고 할 때, email의 카디널리티가 높기 때문에 email에 인덱스를 먼저 생성하는 것이 좋다.  
<br>

### 인덱스 사용 시 주의점
인덱스가 적용된 컬럼이 조건식에서 인덱스를 탈 수 있게 하기위해서 주의해야할 점이 있다.
**해당 컬럼을 가공하지 않거나 연산을 하지 않은 상태에서 비교해야 인덱스를 탄다.**

그 이유는 인덱스 컬럼에 변형이 일어나면 where 절에서 비교되기 전에 가공이 먼저 되기 떄문이다.
인덱스는 가공되기 전의 값으로 생성 되있기 때문에 인덱스를 사용할 수 없게 되는것이다.

CREATEDATE가 인덱스라고 가정해보자
```
SELECT * FROM CUST WHERE CREATEDATE+1 = 3;
-- 인덱스 안탄다. (비교 전 인덱스에 가공이 일어났기 때문)
```
```
SELECT * FROM CUST WHERE CREATEDATE = 3;         
-- 인덱스 탄다. (가공 X)
```
```
SELECT * FROM CUST WHERE CONCAT(DATE,TIME)
-- CONCAT이라는 함수를 사용하여 인덱스를 가공했기에 인덱스를 타지 않는다
```

인덱스를 타지 않는 또 다른 예들을 더 보자면
- LIKE ‘%문자열%’로 검색 (문자열%(가능))
- 부정 연산자(!=,<>,NOT IN, NOT EXISTS)를 사용
- OR 구문을 사용
- **복합 인덱스**의 경우에는 인덱스 생성시 **순서**가 중요하다 ! 

```
CREATE INDEX student_index on Student (department, student_id);
```
위와 같은 복합인덱스의 경우는 `where 학번 = "12192152"` 로 조회했을 때 인덱스를 타지 않는다. 

이유는 index를 (department, student_id) 순으로 생성하여, 학과명 > 학번 순으로 정렬이 되기 때문이다. department가 순서가 먼저이므로 student_id가 정렬 되어 있지 않아 "12192152"이 어디에 있을 지 모르기 때문에 모두 탐색해야한다. 


[참고하면 좋을 블로그](https://burning-dba.tistory.com/79) 

[참고하면 좋을 블로그2](https://coding-factory.tistory.com/755)

<br>

### 인덱스를 타는지 안타는지 확인하는 방법은?
MySQL의 Explain을 사용하면 된다. explain은 쿼리의 실행 계획을 반환해주므로 쿼리 튜닝, 성능 분석, 전략 수집 등의 기초가 된다. 

사용 방법은 단순하다. SELECT문 앞에 explain을 붙여주면 된다.
```
explain select * from booking  where resource_id=1 and start_time > NOW() order by rand();
```

