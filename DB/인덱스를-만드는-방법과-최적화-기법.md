# 인덱스를 만드는 방법
1. **MySQL**

MySQL에는 `클러스터형 인덱스`와 `세컨더리 인덱스`가 존재한다.

### 클러스터형 인덱스 
- 테이블당 하나를 설정할 수 있음.  
- primary key로 기본키를 만들면 클러스터형 인덱스 생성 가능 
- 기본키를 만들지 않고 unique not null 로 클러스터형 인덱스 생성 가능 

### 세컨더리 인덱스 
- ```create index ...``` 명령어 사용 
- 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 떄 생성해야하는 인덱스 

### 사용하는 경우 
하나의 인덱스만 생성할 것이라면 **클러스터형 인덱스**를 만드는 것이 성능이 좋다. 

**세컨더리 인덱스**는 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하기 때문에 age, name, email 등 다양한 필드를 기반으로 쿼리를 보낼 때 사용해야한다. 
<br>
<br>

2. **MongoDB**

- 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됨
- 세컨더리키도 부가적으로 설정해 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수도 있다.


아래와 같이 컬렉션(numbers)에 `createIndex()` 명령을 사용하여 num 키에 대한 인덱스를 생성해보았다. 
```
> db.numbers.createIndex({num: 1},{name:"index_num"})

-- 결과 메세지 
{
        "createdCollectionAutomatically" : false,
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 2,
        "ok" : 1
}
```

위의 예제에서는 num 키에 대해서 인덱스를 생성하는 것이며 :1 은 오름차순 정렬을 의미하며 :-1은 내림차순 정렬을 의미한다. 그리고 인덱스 이름은 index_num 으로 생성했다.

이제 결과 메세지를 살펴보자 
- **createdCollectionAutomatically** : createIndex() 명령어를 통해 새로운 collection을 생성했는지 여부이다. 기존 collection에 unique key만 생성한 것이라면 false가 정상이다. 만약 기존에 없는 collection에 위 명령어를 사용하면 새로운 collection을 생성하면서 이 값은 true를 반환한다.
- **numIndexesBefore** : 인덱스를 생성하기 전의 인덱스 수를 의미
- **numIndexesAfter** : 생성 후 인덱스 수를 의미
컬렉션이 생성되면 _id 에 대해서 프라이머리 키가 생성되기 때문에 생성 전이 1이고, 인덱스 생성 후가 2 인 것을 확인 할 수 있다.
<br>
<br>

# 인덱스 최적화 기법 (MongoDB 기준)

### 1. 인덱스는 비용이다. 

인덱스는 인덱스 리스트, 컬렉션 순으로 탐색하기 때문에 두번 탐색하게 된다. 

또한 컬렉션이 수정되었을 때 인덱스로 수정되어야 하기 때문에 B-트리의 높이를 균형있게 조절하는 비용도 들고, 데이터를 효율적으로 조히할 수 있도록 분산시키는 비용도 들게된다. 

그렇기 때문에 쿼리에 있는 필드에 인덱스를 무작정 다 설정하는 것은 좋지 않다. 또한 컬렉션에서 가져와야 하는 양이 많다면 이 또한 인덱스르 사용하는 것이 좋지 않다. 
<br><br>

### 2. 항상 테스팅하라. 

인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문이다. 그렇기 때문에 항상 테스팅하는 것이 중요하다. 
아래와 같이 `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화 해야한다. (MySQL 기준)
```
explain select * from t1 join t2 on t1.c1 = t2.c1
```
<br><br>

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다. 

복합 인덱스를 생성할 때에는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라진다. 때문에 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 한다. 

1) 어떠한 값과 같음을 비교하는 `==` 이나 `equal` 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다. 
2) 정렬에 쓰는 필드라면 그다음 인덱스로 설정한다. 
3) 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 `>` 이거나 `<` 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정하자. 
4) 유니크한 값의 정도를 카디널리티라고 하는데, 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 한다. 예를 들어 age와 email이 있다고 할 때, email의 카디널리티가 높기 때문에 email에 인덱스를 먼저 생성하는 것이 좋다.  