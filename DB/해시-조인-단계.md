# 해시 조인 단계

메모리에 해시 테이블을 생성하여 조인을 실행하는 해시 조인은 빌드 단계, 프로브 단계로 나뉩니다. (MySql)

<br> 

## 예시로 사용할 쿼리
```
SELECT 
    given_name, country_name
FROM 
    persons 
JOIN 
    countries 
ON 
    persons.country_id = countries.country_id;
```

## 빌드 단계

MySql에서 조인을 실행시 조인 속성을 해시 테이블 키로 사용하여 입력 중 하나의 행이 저장되는 In Memory Hash Table을 빌드합니다. 이 때 해시 테이블 키로 사용되는 속성은 조인하는 두 개의 테이블 중 바이트가 더 작은 테이블의 속성입니다.

예시 쿼리를 수행할 때 빌드 단계는 다음 그림과 같습니다. (countries 테이블의 바이트가 더 작다고 가정)

![image](https://hoing.io/storage/2021/01/build-phase-1.jpg)

<br>

## 프로브 단계

프로브 단계에선 메모리에 올라가지 않은 다른 테이블의 속성으로 행과 일치하는 해시 테이블을 조사합니다. 각 일치에 대해 결합 된 행이 클라이언트로 전송되고, 일치하는 행을 찾기 위해 일정한 시간 조회를 사용하여 각 입력을 한 번 씩 만 스캔한 것을 알 수 있습니다.

예시 쿼리를 수행할 때 프로브 단계는 다음 그림과 같습니다. (나머지 테이블인 persons테이블의 country_id로 해시 테이블 조회)

![image](https://hoing.io/storage/2021/01/probe-phase-1.jpg)

<br>

## 빌드 입력이 메모리 크기보다 크다면?

만약 빌드 단계에서 해시 테이블 키로 사용된 테이블인 countries 테이블의 크기가 메모리 크기 보다 크다면 어떻게 메모리내에 해시 테이블을 만들고 조인을 수행할까요?

빌드 단계에서 설정된 버퍼 메모리가 가득 차면 서버는 나머지 빌드 입력을 디스크의 여러 청크 파일에 기록하게 됩니다. 이 때 디스크에 기록하는 해시 함수는 메모리에서 테이블을 만들때 사용한 해시 함수와는 다른 함수를 사용합니다. (hash_2) 

![image](https://hoing.io/storage/2021/01/build-phase-on-disk-1.jpg)


이렇게 되면 메모리에서 일치하는 행을 찾지 못했더라도 디스크에 기록된 빌드 입력의 청크 파일에서 일치하는 행을 찾을 수 있기 때문에 프로브 입력의 각 행도 청크 파일 세트에 기록합니다.

행이 기록되는 청크 파일은 빌드 입력이 디스크에 기록 될 때 사용되는 동일한 해시 함수 및 공식을 사용하여 결정됩니다 이렇게 하면 두 입력 사이에 일치하는 행이 동일한 청크 파일 쌍에 위치하게됩니다.

![image](https://hoing.io/storage/2021/01/probe-phase-on-disk.jpg)

위의 모든 단계가 끝났다면 이제 메모리에 존재하는 테이블로 먼저 프로브 단계를 수행하고  완료되면 디스크에서 메모리에 올릴 청크 파일을 읽기 시작합니다. 일반적으로 첫 번째 청크 파일 세트를 빌드 및 프로브 입력으로 사용하여 다시 빌드 및 프로브 단계를 수행합니다. 

## MySql 버젼별 해시 조인 변경 사항
- 8.0.18 -> 8.0.20 
    - 원래 동등 조인(equi-join conditions) 에서만 해시 조인이 가능했지만 8.0.20 부터 가능하고 동등 조인이 아닌 조건은 조인이 실행 된 후 필터로 적용됨.
    - outer join 에서 해시 조인 사용 가능. 또한 조인 SQL 문 중 anti join(not exists) 나 semi join(in 절 서브쿼리) 가 포함되어 있어도 가능